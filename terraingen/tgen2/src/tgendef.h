// Definitions (autogenerated)

#include <stdint.h>

typedef float vec3[3];
typedef int64_t qvec3[3];
typedef int32_t ivec3[3];

struct ItemUpgrade // size 8
{
    int8_t x;
    int8_t y;
    int8_t z;
    int8_t material;
    int32_t level;
};
static_assert(sizeof(ItemUpgrade) == 8,
              "Invalid size for ItemUpgrade");
struct ItemData // size 280
{
    uint8_t type;
    uint8_t sub_type;
    uint8_t pad2[2];
    uint32_t modifier;
    uint32_t minus_modifier;
    uint8_t rarity;
    uint8_t material;
    uint8_t flags;
    uint8_t pad8[1];
    int16_t level;
    uint8_t pad10[2];
    ItemUpgrade items[32];
    uint32_t upgrade_count;
};
static_assert(sizeof(ItemData) == 280,
              "Invalid size for ItemData");
struct AppearanceData // size 172
{
    uint8_t not_used_1;
    uint8_t not_used_2;
    uint8_t hair_red;
    uint8_t hair_green;
    uint8_t hair_blue;
    uint8_t pad5[1];
    uint16_t flags;
    vec3 scale;
    int16_t head_model;
    int16_t hair_model;
    int16_t hand_model;
    int16_t foot_model;
    int16_t body_model;
    int16_t tail_model;
    int16_t shoulder2_model;
    int16_t wing_model;
    float head_scale;
    float body_scale;
    float hand_scale;
    float foot_scale;
    float shoulder2_scale;
    float weapon_scale;
    float tail_scale;
    float shoulder_scale;
    float wing_scale;
    float body_pitch;
    float arm_pitch;
    float arm_roll;
    float arm_yaw;
    float feet_pitch;
    float wing_pitch;
    float back_pitch;
    vec3 body_offset;
    vec3 head_offset;
    vec3 hand_offset;
    vec3 foot_offset;
    vec3 tail_offset;
    vec3 wing_offset;
};
static_assert(sizeof(AppearanceData) == 172,
              "Invalid size for AppearanceData");
struct EntityData // size 4456
{
    qvec3 pos;
    float body_roll;
    float body_pitch;
    float body_yaw;
    vec3 velocity;
    vec3 accel;
    vec3 extra_vel;
    float look_pitch;
    uint32_t physics_flags;
    uint8_t hostile_type;
    int8_t pad10[3];
    uint32_t entity_type;
    uint8_t current_mode;
    int8_t pad13[3];
    uint32_t mode_start_time;
    uint32_t hit_counter;
    uint32_t last_hit_time;
    AppearanceData appearance;
    uint16_t flags;
    int8_t pad19[2];
    uint32_t roll_time;
    int32_t stun_time;
    uint32_t slowed_time;
    uint32_t make_blue_time;
    uint32_t speed_up_time;
    float show_patch_time;
    uint8_t class_type;
    uint8_t specialization;
    int8_t pad28[2];
    float charged_mp;
    uint32_t not_used_1;
    uint32_t not_used_2;
    uint32_t not_used_3;
    uint32_t not_used_4;
    uint32_t not_used_5;
    uint32_t not_used_6;
    vec3 ray_hit;
    float hp;
    float mp;
    float block_power;
    float max_hp_multiplier;
    float shoot_speed;
    float damage_multiplier;
    float armor_multiplier;
    float resi_multiplier;
    uint8_t not_used7;
    uint8_t not_used8;
    int8_t pad47[2];
    int32_t level;
    int32_t current_xp;
    uint64_t parent_owner;
    uint32_t unknown_or_not_used1;
    uint32_t unknown_or_not_used2;
    uint8_t power_base;
    int8_t pad54[3];
    int32_t unknown_or_not_used4;
    ivec3 start_chunk;
    uint32_t super_weird;
    qvec3 spawn_pos;
    uint8_t not_used19;
    int8_t pad60[3];
    ivec3 not_used20;
    ItemData consumable;
    ItemData equipment[13];
    uint32_t skills[11];
    uint32_t mana_cubes;
    int8_t name[16];
};
static_assert(sizeof(EntityData) == 4456,
              "Invalid size for EntityData");
struct ItemWithHeader // size 284
{
    uint32_t header;
    ItemData data;
};
static_assert(sizeof(ItemWithHeader) == 284,
              "Invalid size for ItemWithHeader");
struct ItemWithHeaderList // size 12
{
    uint32_t vec_start;
    uint32_t vec_end;
    uint32_t vec_capacity;
};
static_assert(sizeof(ItemWithHeaderList) == 12,
              "Invalid size for ItemWithHeaderList");
struct ItemWithHeaderLists // size 12
{
    uint32_t vec_start;
    uint32_t vec_end;
    uint32_t vec_capacity;
};
static_assert(sizeof(ItemWithHeaderLists) == 12,
              "Invalid size for ItemWithHeaderLists");
struct StaticEntityHeader // size 72
{
    uint32_t entity_type;
    int8_t pad1[4];
    qvec3 pos;
    uint32_t orientation;
    vec3 size;
    uint8_t closed;
    int8_t pad6[3];
    uint32_t time_offset;
    uint32_t something8;
    int8_t pad9[4];
    uint64_t user_id;
};
static_assert(sizeof(StaticEntityHeader) == 72,
              "Invalid size for StaticEntityHeader");
struct StaticEntity // size 392
{
    StaticEntityHeader header;
    ItemWithHeaderLists item_with_header_lists;
    uint32_t something1;
    ItemData item;
    uint32_t something2;
    uint32_t something3;
    uint32_t something4;
    uint32_t something5;
    uint32_t something6;
    uint32_t something7;
};
static_assert(sizeof(StaticEntity) == 392,
              "Invalid size for StaticEntity");
struct ItemWithExtra // size 304
{
    ItemWithHeaderLists lists;
    uint32_t something1;
    ItemData item;
    uint32_t something_added1;
    uint32_t something_added2;
};
static_assert(sizeof(ItemWithExtra) == 304,
              "Invalid size for ItemWithExtra");
struct Spawn // size 4336
{
    uint32_t vtable;
    int8_t pad1[4];
    float something1;
    int8_t something2[4];
    int64_t x;
    int64_t y;
    int64_t z;
    int8_t hostile_type;
    int8_t something3[3];
    uint32_t entity_type;
    int8_t class_type;
    int8_t specialization;
    int8_t pad12[2];
    uint32_t level;
    uint32_t something33;
    uint32_t something34;
    uint32_t something35;
    uint32_t something36;
    uint64_t entity_id;
    int8_t enable_flag_8_flags_1;
    int8_t pad20[3];
    float body_yaw;
    int8_t power_base;
    int8_t pad23[3];
    int8_t not_used19;
    int8_t pad25[3];
    uint32_t not_used20;
    uint32_t not_used21;
    uint32_t not_used22;
    uint32_t something14;
    uint32_t something15;
    AppearanceData appearance;
    ItemData items[13];
    float max_hp_multiplier;
    float shoot_speed;
    float damage_multiplier;
    float armor_multiplier;
    float resi_multiplier;
    ItemWithExtra extra_item;
    uint32_t some_12b_p;
    uint32_t some_vec_start;
    uint32_t some_vec_end;
    uint32_t some_vec_capacity;
    uint32_t id_vec_1_start;
    uint32_t id_vec_1_end;
    uint32_t id_vec_1_capacity;
    uint32_t id_vec_2_end_old;
    uint32_t id_vec_2_start;
    uint32_t id_vec_2_end;
    uint32_t id_vec_2_capacity;
    uint32_t unknown_or_not_used4;
    int8_t name[16];
    uint32_t something30;
    uint32_t something31;
    uint32_t something32;
    int8_t something37;
    int8_t pad56[7];
};
static_assert(sizeof(Spawn) == 4336,
              "Invalid size for Spawn");
struct CriticalSection // size 24
{
    uint32_t DebugInfo;
    uint32_t LockCount;
    uint32_t RecursionCount;
    uint32_t OwningThread;
    uint32_t LockSemaphore;
    uint32_t SpinCount;
};
static_assert(sizeof(CriticalSection) == 24,
              "Invalid size for CriticalSection");
struct Color // size 4
{
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
};
static_assert(sizeof(Color) == 4,
              "Invalid size for Color");
struct Field // size 32
{
    uint32_t vtable;
    float f1;
    float f2;
    float f3;
    uint32_t a;
    uint32_t b;
    uint32_t data;
    uint32_t size;
};
static_assert(sizeof(Field) == 32,
              "Invalid size for Field");
struct ChunkItemData // size 328
{
    ItemData item_data;
    qvec3 pos;
    float rotation;
    float scale;
    uint8_t something3;
    int8_t pad5[3];
    uint32_t drop_time;
    uint32_t something5;
    uint32_t something6;
};
static_assert(sizeof(ChunkItemData) == 328,
              "Invalid size for ChunkItemData");
struct Zone // size 200
{
    int32_t vtable;
    int32_t b;
    int32_t c;
    uint32_t static_entities_start;
    uint32_t static_entities_end;
    uint32_t static_entities_capacity;
    uint32_t spawns_start;
    uint32_t spawns_end;
    uint32_t spawns_capacity;
    uint32_t some4_start;
    uint32_t some4_end;
    uint32_t some4_capacity;
    uint32_t items_start;
    uint32_t items_end;
    uint32_t items_capacity;
    uint32_t some9_start;
    uint32_t some9_end;
    uint32_t some9_capacity;
    uint32_t some8_start;
    uint32_t some8_end;
    uint32_t some8_capacity;
    uint32_t some7_start;
    uint32_t some7_end;
    uint32_t some7_capacity;
    uint32_t chunk_x;
    uint32_t chunk_y;
    uint32_t some2_20byte_start;
    uint32_t some2_20byte_end;
    uint32_t some2_20byte_capacity;
    uint8_t word74;
    uint8_t has_chunkitems;
    uint8_t byte76;
    uint8_t pad32;
    uint32_t dword78;
    uint32_t dword7C;
    uint32_t dword80;
    uint8_t byte84;
    uint8_t pad37[3];
    uint32_t some5_start;
    uint32_t some5_end;
    uint32_t some5_capacity;
    uint32_t some6_start;
    uint32_t some6_end;
    uint32_t some6_capacity;
    uint32_t start_something_dynamic_entities;
    uint32_t dwordA4;
    uint32_t fields;
    uint32_t other_chunk_data;
    CriticalSection crit_sec;
};
static_assert(sizeof(Zone) == 200,
              "Invalid size for Zone");
struct SomethingCreature // size 2192
{
    uint32_t dword0;
    uint32_t dword4;
    uint32_t dword8;
    uint32_t dwordC;
    uint32_t dword10;
    uint32_t dword14;
    uint32_t dword18;
    uint32_t dword1C;
    uint32_t dword20;
    uint32_t dword24;
    uint32_t dword28;
    uint32_t dword2C;
    uint32_t dword30;
    uint32_t dword34;
    uint32_t dword38;
    uint32_t dword3C;
    uint32_t dword40;
    uint32_t dword44;
    uint32_t dword48;
    uint32_t dword4C;
    uint32_t dword50;
    uint32_t dword54;
    uint32_t dword58;
    uint32_t dword5C;
    uint32_t dword60;
    uint32_t dword64;
    uint32_t dword68;
    uint32_t dword6C;
    uint32_t dword70;
    uint32_t dword74;
    uint32_t dword78;
    uint32_t dword7C;
    uint32_t dword80;
    uint32_t dword84;
    uint32_t dword88;
    uint32_t dword8C;
    uint32_t dword90;
    uint32_t dword94;
    uint32_t dword98;
    uint32_t dword9C;
    uint32_t dwordA0;
    uint32_t dwordA4;
    uint32_t dwordA8;
    uint32_t dwordAC;
    uint32_t dwordB0;
    uint32_t dwordB4;
    uint32_t dwordB8;
    uint32_t dwordBC;
    uint8_t pad48[4];
    uint32_t dwordC4;
    uint32_t dwordC8;
    uint32_t dwordCC;
    uint32_t dwordD0;
    uint32_t dwordD4;
    uint32_t dwordD8;
    uint32_t dwordDC;
    uint8_t pad56[4];
    uint32_t dwordE4;
    uint32_t dwordE8;
    uint8_t pad59[1920];
    uint32_t dword86C;
    uint32_t dword870;
    uint32_t dword874;
    uint8_t byte878;
    uint8_t pad64[7];
    uint32_t dword880;
    uint32_t dword884;
    uint32_t dword888;
    uint32_t dword88C;
};
static_assert(sizeof(SomethingCreature) == 2192,
              "Invalid size for SomethingCreature");
struct Creature // size 7776
{
    uint32_t vtable;
    uint8_t f4[4];
    uint64_t entity_id;
    EntityData entity_data;
    uint32_t ptr32_1178;
    uint32_t dword117C;
    uint32_t dword1180;
    uint32_t dword1184;
    uint32_t dword1188;
    uint32_t dword118C;
    uint32_t dword1190;
    float float1194;
    float float1198;
    uint32_t dword119C;
    uint8_t f11A0[12];
    uint32_t mapptr24_11AC;
    uint32_t dword11B0;
    uint32_t mapptr24_11B4;
    uint32_t dword11B8;
    uint8_t f11BC[4];
    uint32_t dword11C0;
    uint32_t dword11C4;
    uint32_t dword11C8;
    uint32_t dword11CC;
    uint32_t dword11D0;
    uint32_t dword11D4;
    uint32_t dword11D8;
    ItemWithExtra item_with_extra;
    uint32_t ptr308_130C;
    uint32_t dword1310;
    uint32_t dword1314;
    uint32_t dword1318;
    uint8_t f131C[52];
    uint32_t dword1350;
    uint32_t dword1354;
    uint32_t dword1358;
    uint32_t dword135C;
    uint32_t dword1360;
    uint32_t dword1364;
    uint8_t f1368[12];
    uint32_t dword1374;
    uint32_t dword1378;
    uint32_t dword137C;
    uint8_t f1380[24];
    uint32_t dword1398;
    uint32_t mapptr24_139C;
    uint32_t dword13A0;
    uint32_t creature_map;
    uint32_t dword13A8;
    uint32_t creature_map2;
    uint32_t dword13B0;
    uint32_t dword13B4;
    uint8_t byte13B8;
    uint8_t f13B9[3];
    uint32_t dword13BC;
    uint8_t byte13C0;
    uint8_t f13C1[3];
    uint32_t dword13C4;
    uint32_t dword13C8;
    uint32_t dword13CC;
    uint32_t dword13D0;
    uint32_t dword13D4;
    float dword13D8;
    uint32_t dword13DC;
    uint32_t dword13E0;
    uint32_t behaviour;
    uint32_t dword13E8;
    uint32_t dword13EC;
    uint32_t dword13F0;
    uint32_t dword13F4;
    uint32_t dword13F8;
    uint32_t dword13FC;
    uint32_t dword1400;
    uint32_t dword1404;
    uint32_t dword1408;
    uint32_t mapptr52_140C;
    uint32_t dword1410;
    uint32_t mapptr28_1414;
    uint32_t dword1418;
    uint32_t dword141C;
    uint32_t dword1420;
    uint32_t dword1424;
    uint8_t f1428[48];
    uint32_t dword1458;
    uint32_t dword145C;
    uint32_t ptr20_1460;
    uint32_t dword1464;
    uint32_t mapptr20_1468;
    uint32_t dword146C;
    uint32_t ptr20_1470;
    uint32_t dword1474;
    uint32_t dword1478;
    uint32_t dword147C;
    uint32_t dword1480;
    uint32_t dword1484;
    uint32_t dword1488;
    uint32_t dword148C;
    uint32_t dword1490;
    uint32_t dword1494;
    SomethingCreature som_c;
    uint32_t dword1D28;
    uint32_t float1D2C;
    uint8_t f1D30[8];
    uint8_t byte1D38;
    uint8_t f1D39[3];
    uint32_t dword1D3C;
    uint32_t dword1D40;
    uint32_t dword1D44;
    uint16_t word1D48;
    uint8_t f1D4A[2];
    uint32_t dword1D4C;
    uint32_t dword1D50;
    uint16_t word1D54;
    uint8_t byte1D56;
    uint8_t f1D57[1];
    uint16_t word1D58;
    uint8_t f1D5A[2];
    int8_t char1D5C[256];
    uint32_t dword1E5C;
};
static_assert(sizeof(Creature) == 7776,
              "Invalid size for Creature");
